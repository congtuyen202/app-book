# Khai báo các Scalar tùy chỉnh
scalar DateTime @scalar(class: "App\\GraphQL\\Scalars\\DateTime")
scalar JSON @scalar(class: "App\\GraphQL\\Scalars\\JSONScalar")
scalar Date @scalar(class: "App\\GraphQL\\Scalars\\DateScalar") # Đã thêm khai báo này

# Uncomment các dòng dưới đây nếu bạn muốn TẤT CẢ các Query/Mutation MẶC ĐỊNH yêu cầu xác thực.
# Nếu không, bạn cần thêm @guard và @can riêng lẻ cho từng Query/Mutation.
# extend type Query @guard(with: ["sanctum"])
# extend type Mutation @guard(with: ["sanctum"])



# Query Root Type
type Query {
    # Publicly accessible (No @guard here directly, but specific fields might be protected)
    books(first: Int = 10, page: Int = 1): [Book!]! @paginate(defaultCount: 10)
    book(id: ID!): Book @find

    # User-specific queries (require authentication and specific permissions)
    users(first: Int = 10, page: Int = 1): [User!]! @paginate(defaultCount: 10) @guard(with: ["sanctum"]) @can(ability: "view-user-profiles", model: "App\\Models\\User")
    user(id: ID!): User @find @guard(with: ["sanctum"])

    # Authors
    authors(first: Int = 10, page: Int = 1): [Author!]! @paginate(defaultCount: 10)
    author(id: ID!): Author @find

    # Genres
    genres(first: Int = 10, page: Int = 1): [Genre!]! @paginate(defaultCount: 10)
    genre(id: ID!): Genre @find

    # Reviews
    reviews(first: Int = 10, page: Int = 1, book_id: ID, user_id: ID): [Review!]! @paginate(defaultCount: 10)
    review(id: ID!): Review @find

    # Quotes
    quotes(first: Int = 10, page: Int = 1, book_id: ID, user_id: ID): [Quote!]! @paginate(defaultCount: 10)
    quote(id: ID!): Quote @find

    # AI Summaries
    aiSummaries(first: Int = 10, page: Int = 1, book_id: ID, ai_model_name: String): [AiSummary!]! @paginate(defaultCount: 10)
    aiSummary(id: ID!): AiSummary @find

    # Posts
    posts(first: Int = 10, page: Int = 1, user_id: ID): [Post!]! @paginate(defaultCount: 10)
    post(id: ID!): Post @find

    # Comments
    comments(first: Int = 10, page: Int = 1, post_id: ID, review_id: ID, user_id: ID): [Comment!]! @paginate(defaultCount: 10)
    comment(id: ID!): Comment @find

    # Likes
    likes(first: Int = 10, page: Int = 1, user_id: ID): [Like!]! @paginate(defaultCount: 10)
    like(id: ID!): Like @find

    # Reading Lists
    readingLists(first: Int = 10, page: Int = 1, user_id: ID): [ReadingList!]! @paginate(defaultCount: 10)
    readingList(id: ID!): ReadingList @find

    # AI Request Logs (typically admin-only or specific roles)
    aiRequestLogs(first: Int = 10, page: Int = 1, user_id: ID, ai_model_name: String): [AiRequestLog!]! @paginate(defaultCount: 10) @guard(with: ["sanctum"]) @can(ability: "view-ai-logs", model: "App\\Models\\User")
    aiRequestLog(id: ID!): AiRequestLog @find
}



# Mutation Root Type
type Mutation {
    # Authentication (No guard needed for login/register as they initiate authentication)
    login(email: String!, password: String!): AuthPayload! @field(resolver: "App\\GraphQL\\Mutations\\AuthMutator@login")
    logout: String! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\AuthMutator@logout")
    register(username: String!, email: String!, password: String!, password_confirmation: String!): User! @create(model: "App\\Models\\User")

    # Book Mutations (Require authentication and specific permissions)
    createBook(input: CreateBookInput!): Book! @create @guard(with: ["sanctum"]) @can(ability: "create-book", model: "App\\Models\\User")
    updateBook(id: ID!, input: UpdateBookInput!): Book! @update @guard(with: ["sanctum"]) @can(ability: "edit-book", model: "App\\Models\\User")
    deleteBook(id: ID!, force: Boolean = false): Book! @delete(force: "$force") @guard(with: ["sanctum"]) @can(ability: "delete-book", model: "App\\Models\\User")

    # Review Mutations
    createReview(book_id: ID!, rating: Int! @rules(apply: ["min:1", "max:5"]), review_text: String): Review! @create(model: "App\\Models\\Review", inject: ["user_id:id"]) @guard(with: ["sanctum"]) @can(ability: "create-review", model: "App\\Models\\User")
    updateReview(id: ID!, input: UpdateReviewInput!): Review! @update @guard(with: ["sanctum"])
        @can(ability: "edit-any-review", find: "id", model: "App\\Models\\User")
        @can(ability: "edit-own-review", find: "id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")
    deleteReview(id: ID!): Review! @delete @guard(with: ["sanctum"])
        @can(ability: "delete-any-review", find: "id", model: "App\\Models\\User")
        @can(ability: "delete-own-review", find: "id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")

    # Post Mutations
    createPost(content: String!, book_id: ID, post_type: String, image_url: String, visibility: String): Post! @create(model: "App\\Models\\Post", inject: ["user_id:id"]) @guard(with: ["sanctum"]) @can(ability: "create-post", model: "App\\Models\\User")
    updatePost(id: ID!, input: UpdatePostInput!): Post! @update @guard(with: ["sanctum"])
        @can(ability: "edit-any-post", find: "id", model: "App\\Models\\User")
        @can(ability: "edit-own-post", find: "id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")
    deletePost(id: ID!): Post! @delete @guard(with: ["sanctum"])
        @can(ability: "delete-any-post", find: "id", model: "App\\Models\\User")
        @can(ability: "delete-own-post", find: "id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")

    # Comment Mutations
    createComment(post_id: ID, review_id: ID, parent_comment_id: ID, content: String!): Comment! @create(model: "App\\Models\\Comment", inject: ["user_id:id"]) @guard(with: ["sanctum"]) @can(ability: "comment-on-posts", model: "App\\Models\\User")
    updateComment(id: ID!, input: UpdateCommentInput!): Comment! @update @guard(with: ["sanctum"])
        @can(ability: "edit-any-comment", find: "id", model: "App\\Models\\User")
        @can(ability: "edit-own-comment", find: "id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")
    deleteComment(id: ID!): Comment! @delete @guard(with: ["sanctum"])
        @can(ability: "delete-any-comment", find: "id", model: "App\\Models\\User")
        @can(ability: "delete-own-comment", find: "id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")

    # Polymorphic Likes
    toggleLike(likeable_id: ID!, likeable_type: String!): Like! @field(resolver: "App\\GraphQL\\Mutations\\Like@toggle") @guard(with: ["sanctum"]) @can(ability: "like-content", model: "App\\Models\\User")

    # Followers
    toggleFollow(followed_id: ID!): User! @field(resolver: "App\\GraphQL\\Mutations\\Follow@toggle") @guard(with: ["sanctum"]) @can(ability: "follow-users", model: "App\\Models\\User")

    # Reading List Mutations
    createReadingList(name: String!, description: String, visibility: String): ReadingList! @create(model: "App\\Models\\ReadingList", inject: ["user_id:id"]) @guard(with: ["sanctum"]) @can(ability: "create-reading-list")
    updateReadingList(id: ID!, input: UpdateReadingListInput!): ReadingList! @update @guard(with: ["sanctum"])
        @can(ability: "edit-own-reading-list", find: "id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")
    deleteReadingList(id: ID!): ReadingList! @delete @guard(with: ["sanctum"])
        @can(ability: "delete-own-reading-list", find: "id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")
    addBookToReadingList(reading_list_id: ID!, book_id: ID!, status: String): ReadingList! @field(resolver: "App\\GraphQL\\Mutations\\ReadingList@addBook") @guard(with: ["sanctum"]) @can(ability: "edit-own-reading-list", find: "reading_list_id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")
    removeBookFromReadingList(reading_list_id: ID!, book_id: ID!): ReadingList! @field(resolver: "App\\GraphQL\\Mutations\\ReadingList@removeBook") @guard(with: ["sanctum"]) @can(ability: "edit-own-reading-list", find: "reading_list_id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")
    updateBookStatusInReadingList(reading_list_id: ID!, book_id: ID!, status: String!, started_reading_at: Date, finished_reading_at: Date): ReadingList! @field(resolver: "App\\GraphQL\\Mutations\\ReadingList@updateBookStatus") @guard(with: ["sanctum"]) @can(ability: "edit-own-reading-list", find: "reading_list_id", field: "user_id", inject: ["user_id:id"], model: "App\\Models\\User")
}

extend type Mutation {
    # Sử dụng Gemini để tạo nội dung văn bản (gợi ý, tóm tắt tùy chỉnh, v.v.)
    generateGeminiText(prompt: String!, usage_type: String!): String!
        @field(resolver: "App\\GraphQL\\Mutations\\GeminiAI@generateTextContent")
        @guard(with: ["sanctum"])
        @can(ability: "use-basic-ai-features", model: "App\\Models\\User") # Yêu cầu quyền cơ bản để sử dụng AI
 
    # Sử dụng Gemini để mô tả hình ảnh
    describeImageWithGemini(imageData: String!, mimeType: String!): String!
        @field(resolver: "App\\GraphQL\\Mutations\\GeminiAI@describeImageContent")
        @guard(with: ["sanctum"])
        @can(ability: "use-basic-ai-features", model: "App\\Models\\User")
}



# Payload for Authentication
type AuthPayload {
    token: String!
    user: User!
}



# Union Type for Polymorphic Relationships
# Đây là nơi bạn đặt định nghĩa Union Type
union Likeable @union(resolveType: "App\\GraphQL\\Resolvers\\LikeableResolver") = Book | Post | Review | Comment



# Type Definitions (representing your Models)

type User {
    id: ID!
    username: String!
    email: String!
    full_name: String
    avatar_url: String
    bio: String
    status: String
    email_verified_at: DateTime
    last_login_at: Auth
    created_at: DateTime!
    updated_at: DateTime!
    # Relationships
    roles: [Role!]! @belongsToMany
    # permissions: [Permission!]! @belongsToMany(related: "permissions") # Nếu bạn muốn lấy trực tiếp các quyền của user
    reviews: [Review!]! @hasMany
    quotes: [Quote!]! @hasMany
    posts: [Post!]! @hasMany
    comments: [Comment!]! @hasMany
    readingLists: [ReadingList!]! @hasMany(relation: "readingLists")
    following: [User!]! @belongsToMany(relation: "following")
    followers: [User!]! @belongsToMany(relation: "followers")
    # TBD: likedItems for polymorphic relations, requires custom resolver for the field or a union type
}

type Role {
    id: ID!
    name: String!
    description: String
    created_at: DateTime!
    updated_at: DateTime!
    users: [User!]! @belongsToMany
    permissions: [Permission!]! @belongsToMany
}

type Permission {
    id: ID!
    name: String!
    description: String
    created_at: DateTime!
    updated_at: DateTime!
    roles: [Role!]! @belongsToMany
}

type Book {
    id: ID!
    title: String!
    original_title: String
    description: String
    published_year: Int
    isbn: String
    language: String
    page_count: Int
    cover_image_url: String
    avg_rating: Float
    rating_count: Int
    created_at: DateTime!
    updated_at: DateTime!
    # Relationships
    authors: [Author!]! @belongsToMany
    genres: [Genre!]! @belongsToMany
    reviews: [Review!]! @hasMany
    aiSummaries: [AiSummary!]! @hasMany(relation: "aiSummaries")
}

type Author {
    id: ID!
    name: String!
    bio: String
    birth_date: Date
    death_date: Date
    nationality: String
    created_at: DateTime!
    updated_at: DateTime!
    books: [Book!]! @belongsToMany
}

type Genre {
    id: ID!
    name: String!
    created_at: DateTime!
    updated_at: DateTime!
    books: [Book!]! @belongsToMany
}

type Review {
    id: ID!
    user_id: ID!
    book_id: ID!
    rating: Int!
    review_text: String
    status: String
    created_at: DateTime!
    updated_at: DateTime!
    user: User! @belongsTo
    book: Book! @belongsTo
    comments: [Comment!]! @hasMany
    likes: [Like!]! @morphMany
}

type Quote {
    id: ID!
    user_id: ID!
    book_id: ID!
    content: String!
    page_number: Int
    context: String
    created_at: DateTime!
    updated_at: DateTime!
    user: User! @belongsTo
    book: Book! @belongsTo
}

type AiSummary {
    id: ID!
    book_id: ID!
    ai_model_name: String!
    summary_type: String!
    content: String!
    token_count: Int
    created_at: DateTime!
    updated_at: DateTime!
    book: Book! @belongsTo
}

type Post {
    id: ID!
    user_id: ID!
    content: String!
    book_id: ID
    post_type: String
    image_url: String
    visibility: String
    created_at: DateTime!
    updated_at: DateTime!
    user: User! @belongsTo
    book: Book @belongsTo
    comments: [Comment!]! @hasMany
    likes: [Like!]! @morphMany
}

type Comment {
    id: ID!
    user_id: ID!
    post_id: ID
    review_id: ID
    parent_comment_id: ID
    content: String!
    created_at: DateTime!
    updated_at: DateTime!
    user: User! @belongsTo
    post: Post @belongsTo
    review: Review @belongsTo
    parentComment: Comment @belongsTo(relation: "parentComment")
    replies: [Comment!]! @hasMany(relation: "replies")
    likes: [Like!]! @morphMany
}

type Like {
    id: ID!
    user_id: ID!
    likeable_type: String!
    likeable_id: ID!
    created_at: DateTime!
    updated_at: DateTime!
    user: User! @belongsTo
    likeable: Likeable! @morphTo # Đã thay Mixed bằng Likeable Union Type
}

type ReadingList {
    id: ID!
    user_id: ID!
    name: String!
    description: String
    visibility: String
    created_at: DateTime!
    updated_at: DateTime!
    user: User! @belongsTo
    books: [BookReadingList!]! @belongsToMany(relation: "books", pivot: ["status", "started_reading_at", "finished_reading_at"])
}

# Để hiển thị các trường pivot trong mối quan hệ many-to-many
type BookReadingList {
    id: ID!
    title: String!
    cover_image_url: String
    pivot: ReadingListBookPivot!
}

type ReadingListBookPivot {
    reading_list_id: ID!
    book_id: ID!
    status: String!
    started_reading_at: Date
    finished_reading_at: Date
}

type AiRequestLog {
    id: ID!
    user_id: ID
    ai_model_name: String!
    request_type: String!
    input_text: String
    output_text: String
    tokens_used: Int
    cost: Float
    status: String!
    error_message: String
    requested_at: DateTime!
    created_at: DateTime!
    updated_at: DateTime!
    user: User @belongsTo
}



# Input Types for Mutations (Creating/Updating Data)
input CreateBookInput {
    title: String!
    original_title: String
    description: String
    published_year: Int
    isbn: String @rules(apply: ["required", "unique:books,isbn"])
    language: String
    page_count: Int
    cover_image_url: String
}

input UpdateBookInput {
    title: String
    original_title: String
    description: String
    published_year: Int
    isbn: String @rules(apply: ["required", "unique:books,isbn,{{args.id}},id"])
    language: String
    page_count: Int
    cover_image_url: String
}

# user_id đã được injected, không cần trong input
input CreateReviewInput {
    book_id: ID!
    rating: Int! @rules(apply: ["min:1", "max:5"])
    review_text: String
}

input UpdateReviewInput {
    rating: Int @rules(apply: ["min:1", "max:5"])
    review_text: String
    status: String
}

# user_id đã được injected, không cần trong input
input CreatePostInput {
    content: String!
    book_id: ID
    post_type: String
    image_url: String
    visibility: String
}

input UpdatePostInput {
    content: String
    book_id: ID
    post_type: String
    image_url: String
    visibility: String
}

# user_id đã được injected, không cần trong input
input CreateCommentInput {
    post_id: ID
    review_id: ID
    parent_comment_id: ID
    content: String!
}

input UpdateCommentInput {
    content: String
}

# user_id đã được injected, không cần trong input
input CreateReadingListInput {
    name: String!
    description: String
    visibility: String
}

input UpdateReadingListInput {
    name: String
    description: String
    visibility: String
}